#!/usr/bin/env node
const fs = require("fs");
const chordFiles = ["chords.json", "personal.json"];
const layoutFile = "layout.json";
const readmeFile = "README.md";
const qmkChordFile = "../qmk-config/chords.c";
const qmkPersonalFile = "../qmk-config/personal.c";
const zmkChordFile = "../zmk-config/config/chords.keymap";
const zmkPersonalFile = "../zmk-config/config/personal.keymap";
const zmkConfigFile = "../zmk-config/config/cradio.conf";
const processedChords = "processed.json";
const keymapFile = "keymap.json";

const tidyReadmeCombo = {
  Ret: "↵",
  Dup: "⨧",
  Bksp: `⌫`,
  Spc: "␣",
  Tab: "⇥",
  Esc: "⎋",
  Caps: "⇪",
};

const tidyKeymap = {
  ...tidyReadmeCombo,
  "left-click": "LClk",
  "Gui-left-click": "⌘LC",
  "right-click": "RClk",
  "oneshot-Function": null,
  "oneshot-Hyper": "Hyper",
  "delete-word": "⌫Word",
  Alph: "A",
  Sym: "λ",
  Num: "#",
  Shft: "⇧",
  Ctrl: "⌃",
  Alt: "⌥",
  Gui: "⌘",
  BtlR: "Boot\nLoad",
  BtlL: "Boot\nLoad",
  RstL: "Reset",
  RstR: "Reset",
  BTCl: "BT\nClear",
  BTTg: "BT\nToggl",
  Alfr: "Alfred",
  BrUp: "Bright\nUp",
  BrDn: "Bright\nDown",
  VlUp: "Volume\nUp",
  VlDn: "Volume\nDown",
  ScSh: "Screen\nShot",
  Lock: "Lock\nScreen",
  Lang: "Switch\nLang",
  PlPs: "Play\nPause",
  ZmIn: "Zoom\nIn/Out",
  Left: "←",
  Down: "↓",
  Up: "↑",
  Rght: "→",
};

const tidyReadmeOutput = {
  "\b": "⌫",
  "*": "\\*",
};

const outputForKey = {
  Spc: " ",
  Bksp: "\b",
  Ret: "\n",
  Tab: "\t",
  Esc: "\x1B",

  Shft: "",
  Ctrl: "",
  Sym: "",
  Num: "",
  Alph: "",

  Alfr: "",
  BrUp: "",
  Lang: "",
  BrDn: "",
  ScSh: "",
  Lock: "",
  Mute: "",
  VlUp: "",
  VlDn: "",
  Prev: "",
  Left: "",
  ZmIn: "",
  ZmOt: "",
  PlPs: "",
  Down: "",
  Next: "",
  Up: "",
  Rght: "",

  BtlL: "",
  RstL: "",
  RstR: "",
  BtlR: "",
  BT1: "",
  BT2: "",
  BT3: "",
  BT4: "",
  BT5: "",
  BT6: "",
  BTCl: "",
  BTTg: "",
};

const intuitLabel = ({ output, behavior }) =>
  (behavior || output)
    .split("")
    .map((l) => tidyReadmeOutput[l] || l)
    .join("");

const intuitIdentifierStem = ({ label }) => {
  let identifier = label.toLowerCase();
  identifier = identifier.replaceAll(/[^a-z_0-9]+/g, "_");
  return identifier.substring(0, 7);
};

const intuitShifted = (output) => {
  const first = output.substr(0, 1);
  const shifted = first.toUpperCase();
  if (first === shifted) {
    return null;
  }

  return shifted + output.substr(1);
};

const parseLayout = (config) => {
  const validKey = {};
  const qmkKey = {};
  const zmkKey = {};
  const keys = [];
  const keymap = [];
  let shiftBase;

  let z = 0;
  config.Alpha.forEach((row) => {
    const keymapRow = [];
    row.forEach((key) => {
      validKey[key] = true;
      zmkKey[key] = z++;
      const k = {};
      keys.push(k);
      keymapRow.push(k);
    });
    keymap.push(keymapRow);
  });

  Object.entries(config).forEach(([layer, rows]) => {
    qmkKey[layer] = {};
    const prefix = layer.substring(0, 1);

    const qmkKeyTidy = {
      ".": `${prefix}_d`,
      ",": `${prefix}_c`,
      Ret: `${prefix}_r`,
      "'": `${prefix}_q`,
    };

    rows[3].forEach((key, i) => {
      qmkKeyTidy[key] = `${prefix}T${i}`;
    });

    let i = 0;
    rows.forEach((row, r) => {
      row.forEach((key, c) => {
        const alpha = config.Alpha[r][c];
        qmkKey[layer][alpha] =
          qmkKeyTidy[alpha] || `${prefix}_${alpha.toUpperCase()}`;

        if (!shiftBase && key === "Shft") {
          shiftBase = [alpha, i];
        }

        keys[i++][layer] = key;

        if (key === null || key === "" || key in outputForKey) {
          return;
        }

        if (key.length !== 1 && key !== "Dup") {
          console.warn(`Layout has key '${key}' which is not in outputForKey`);
        }
      });
    });
  });

  const layers = Object.keys(config).filter(
    (l) =>
      !l.endsWith("-Shift") &&
      !l.endsWith("-Ctrl") &&
      !l.endsWith("-Alt") &&
      !l.endsWith("-Gui") &&
      !l.endsWith("-Hold")
  );

  const layerIndex = {};
  layers.forEach((layer, i) => {
    layerIndex[layer] = i;
  });

  const zmkLayers = layers.filter((l) => l !== "Function");

  return {
    layers,
    keys,
    keymap,
    validKey,
    layerIndex,
    shiftBase,
    qmkKey,
    zmkKey,
    zmkLayers,
  };
};

const parsedLayout = parseLayout(JSON.parse(fs.readFileSync(layoutFile)));
const { validKey, layerIndex, shiftBase, qmkKey, zmkKey, zmkLayers } =
  parsedLayout;
const layout = {
  layers: parsedLayout.layers,
  keys: parsedLayout.keys,
  keymap: parsedLayout.keymap,
  outputForKey,
  shiftBase,
};

const validateCombo = ({ combo }) => {
  combo.forEach((key) => {
    if (!validKey[key]) {
      throw new Error(`Unexpected combo key '${key}'`);
    }
  });
};

const makeAlternates = ({ output, exact }) => {
  if (!Array.isArray(output) || output.length === 1) {
    return null;
  }

  const alternates = [];
  for (let i = 0, max = output.length - 1; i < max; i++) {
    alternates.push([i, i + 1, output[i], output[i + 1]]);
  }
  const i = output.length - 1;
  alternates.push([i, 0, output[i], output[0]]);

  return alternates.map((alt) => {
    let [, , from, to] = alt;

    if (!exact) {
      from += " ";
      to += " ";
    }

    let f = from;

    while (f.length) {
      if (to.substr(0, f.length) === f) {
        break;
      }
      f = f.substring(0, f.length - 1);
    }

    let backspaces = from.length - f.length;
    let append = to.substring(f.length);

    if (!exact) {
      append = append.substring(0, append.length - 1);
    }

    return {
      fromIdx: alt[0],
      toIdx: alt[1],
      from: alt[2],
      to: alt[3],
      backspaces,
      append,
      exact,
    };
  });
};

const parseChords = (files) => {
  const result = [];
  let seenIdentifier = {};

  files.forEach(({ chords, defaults }) => {
    chords.forEach((input) => {
      if (typeof input === "string") {
        result.push(input);
        return;
      }

      try {
        const chord = { ...defaults, ...input };

        if (chord.combo.length === 0) {
          return;
        }
        validateCombo(chord);

        chord.tap = {};
        [
          "output",
          "behavior",
          "shift",
          "exact",
          "sentenceShift",
          "skipSentence",
        ].forEach((key) => {
          if (key in chord) {
            chord.tap[key] = chord[key];
            delete chord[key];
          }
        });

        if (chord.hold) {
          if (typeof chord.hold === "string" || Array.isArray(chord.hold)) {
            chord.hold = {
              output: chord.hold,
            };
            ["exact", "sentenceShift", "skipSentence"].forEach((key) => {
              if (key in chord.tap) {
                chord.hold[key] = chord.tap[key];
              }
            });
          }
        }

        [chord.tap, chord.hold].filter(Boolean).forEach((action) => {
          action.originalOutput = action.output;

          const alternates = makeAlternates(action);
          if (alternates) {
            action.alternates = alternates;
          }
          if (Array.isArray(action.output)) {
            action.output = action.output[0];
          }
        });

        [chord.tap, chord.hold].filter(Boolean).forEach((action) => {
          let shifted = null;
          let alternates = null;
          let intuited = false;

          const originalOutput = action.originalOutput;
          delete action.originalOutput;

          if ("shift" in action) {
            if (action.shift === null) {
              delete action.shift;
              return;
            }

            alternates = makeAlternates({
              output: action.shift,
              exact: action.exact,
            });
            shifted = Array.isArray(action.shift)
              ? action.shift[0]
              : action.shift;
          } else if ("output" in action) {
            intuited = true;
            shifted = intuitShifted(action.output);
            if (Array.isArray(originalOutput)) {
              const shiftedOutput = originalOutput.map((output) => {
                const shifted = intuitShifted(output);
                return shifted === null ? output : shifted;
              });
              alternates = makeAlternates({
                output: shiftedOutput,
                exact: action.exact,
              });
            }
          }

          if (shifted === null) {
            return;
          }

          action.shift = {
            output: shifted,
            intuited,
          };

          if (alternates) {
            action.shift.alternates = alternates;
          }

          ["exact", "sentenceShift", "skipSentence"].forEach((key) => {
            if (key in action) {
              action.shift[key] = action[key];
            }
          });
        });

        if (chord.label === undefined) {
          chord.label = intuitLabel(chord.tap);
        }

        if (typeof chord.layers === "string") {
          chord.layers = [chord.layers];
        }

        if (chord.identifier === undefined) {
          const stem = intuitIdentifierStem(chord);
          let identifier = stem;
          let i = 0;
          while (seenIdentifier[identifier]) {
            i++;
            identifier = stem + i;
          }
          chord.identifier = identifier;
        } else {
          if (seenIdentifier[chord.identifier]) {
            throw new Error(`Duplicate identifier '${chord.identifier}'`);
          }
        }
        seenIdentifier[chord.identifier] = true;

        if (!chord.identifier.match(/^[a-z_][a-z_0-9]{0,8}$/)) {
          throw new Error(`Malformed identifier '${chord.identifier}'`);
        }

        result.push(chord);
      } catch (err) {
        throw new Error(`${err.message} in chord '${JSON.stringify(input)}'`);
      }
    });
  });

  return result;
};

const dropAfter = (xs, re) => {
  const i = xs.findIndex((x) => x.match(re));
  return i === -1 ? xs : xs.slice(0, i);
};

const macro = (name, params, lines) => {
  const sig = params === null ? "" : `(${params.join(", ")})`;
  const define = `#define ${name}${sig}`;
  if (Array.isArray(lines)) {
    return [define, ...lines.map((l) => `  ${l}`)].join(" \\\n");
  } else {
    return [`${define} ${lines}`];
  }
};

const renderCombo = ({ combo }) => {
  return combo
    .map((key) =>
      ["`", key in tidyReadmeCombo ? tidyReadmeCombo[key] : key, "`"].join("")
    )
    .join(" + ");
};

const renderOutputAction = ({ behavior, output, alternates, shift }) => {
  if (behavior) {
    return `_${behavior}_`;
  }

  if (shift && !shift.intuited) {
    const baseOutput = renderOutputAction({ behavior, output, alternates });
    const shiftOutput = renderOutputAction(shift);

    return `${baseOutput} (shifted: ${shiftOutput})`;
  }

  const outputs = [output];
  if (alternates) {
    alternates.forEach(({ to, toIdx }) => {
      if (toIdx !== 0) {
        outputs.push(to);
      }
    });
  }

  return outputs
    .map((output) =>
      output
        .split("")
        .map((letter) =>
          letter in tidyReadmeOutput ? tidyReadmeOutput[letter] : letter
        )
        .join("")
    )
    .join(" → ");
};

const renderOutput = ({ tap, hold }) => {
  const tapOutput = renderOutputAction(tap);

  if (hold) {
    const holdOutput = renderOutputAction(hold);
    return `tap: ${tapOutput} / hold: ${holdOutput}`;
  }

  return tapOutput;
};

const readmeContent = (chordsAndCategories, original) => {
  const lines = dropAfter(original, new RegExp(/^## \d+ chords$/));

  const visibleChords = chordsAndCategories.filter(
    (chord) => typeof chord === "object" && !chord.quiet
  );
  lines.push(`## ${visibleChords.length} chords`);

  chordsAndCategories.forEach((chord) => {
    if (typeof chord === "string") {
      lines.push("", `### ${chord}`, "");
      return;
    }

    const { quiet } = chord;
    if (quiet) {
      return;
    }
    lines.push(`- ${renderCombo(chord)} → ${renderOutput(chord)}`);
  });
  lines.push("");

  return lines;
};

const qmkCombo = ({ combo, layers }, shift) => {
  let layer = "Alpha";

  if (Array.isArray(layers)) {
    if (layers.length > 1) {
      throw new Error(`Cannot yet encode combo for multiple layers ${layers}`);
    } else {
      layer = layers[0];
    }
  }

  const keys = [...combo];
  if (shift) {
    const [key] = shiftBase;
    keys.push(key);
  }

  return keys.map((key) => qmkKey[layer][key]).join(", ");
};

const qmkOutput = (output, forbidSimple) => {
  const out = [];
  let rest = output;
  let buf = [];
  let ascii = null;
  let length = 0;
  let simple = !forbidSimple;

  const emit = () => {
    if (buf.length) {
      if (ascii) {
        out.push(`SEND_STRING("${buf.join("")}");`);
      } else {
        simple = false;
        out.push(`send_unicode_string("${buf.join("")}");`);
      }
    }
    buf = [];
    ascii = null;
  };

  while (rest.length) {
    const head = rest.substring(0, 1);
    rest = rest.substring(1);

    if (head === "\b") {
      emit();
      out.push("tap_code16(KC_BSPC);");
      simple = false;
      length--;
      continue;
    }

    if (head.charCodeAt(0) > 127) {
      if (ascii == true) {
        emit();
      }
      ascii = false;
    } else {
      if (ascii == false) {
        emit();
      }
      ascii = true;
    }

    length++;
    buf.push(head);
  }

  emit();

  if (simple && out.length === 1) {
    return output;
  }

  return [out, length];
};

const qmkModifier = {
  Shift: "MOD_LSFT",
  Ctrl: "MOD_LCTL",
  Alt: "MOD_LALT",
  Gui: "MOD_LGUI",
  Hyper: "MOD_LCTL | MOD_LALT | MOD_LGUI",
};

const qmkBehaviorAction = ({ behavior }, pressed) => {
  const res = (() => {
    if (behavior.startsWith("oneshot-")) {
      const rest = behavior.replace("oneshot-", "");
      if (rest in layerIndex) {
        if (pressed) {
          return `set_oneshot_layer(${rest.toUpperCase()}, ONESHOT_START);`;
        } else {
          return "clear_oneshot_layer_state(ONESHOT_PRESSED);";
        }
      } else if (rest in qmkModifier) {
        if (pressed) {
          return `oneshot_mods = ${qmkModifier[rest]};`;
        } else {
          return null;
        }
      }
    }

    switch (behavior) {
      case "delete-word":
        if (pressed) {
          return `if (prev_chord_length) {
  for (uint16_t i = 0; i < prev_chord_length; i++) {
    tap_code16(KC_BSPC);
  }
  last_chord_length = 0;
}
else {
  tap_code16(LALT(KC_BSPC));
}
prev_chord_skipsentence = false;
prev_chord_space = false;`;
        }
        break;

      case "left-click":
        if (pressed) {
          return "tap_code16(KC_MS_BTN1);";
        }
        break;

      case "right-click":
        if (pressed) {
          return "tap_code16(KC_MS_BTN2);";
        }
        break;

      case "Gui-left-click":
        if (pressed) {
          return [
            `register_mods(${qmkModifier.Gui});`,
            "tap_code16(KC_MS_BTN1);",
            `unregister_mods(${qmkModifier.Gui});`,
          ];
        }
        break;

      default:
        throw new Error(`Unimplemented qmkBehaviorAction '${behavior}'`);
    }

    return null;
  })();

  return typeof res === "string" ? res.split("\n") : res;
};

const allEqualOr = (values, fallback) => {
  let v = values[0];
  for (let i = 1, len = values.length; i < len; ++i) {
    if (values[i] !== v) {
      return fallback;
    }
  }
  return v;
};

const qmkOutputActionCase = (action, conditional) => {
  const actions = [];

  if (!action.shift) {
    actions.push([action, qmkOutput(action.output, true)]);
  } else if (action.shift.intuited) {
    actions.push([action, qmkOutput(action.output)]);
  } else {
    actions.push([action, qmkOutput(action.output, true)]);
    actions.push([action.shift, qmkOutput(action.shift.output, true)]);
  }

  const allExact = allEqualOr(
    actions.map(([{ exact, sentenceShift }]) =>
      sentenceShift === null ? exact : null
    ),
    null
  );

  const allLength = allEqualOr(
    actions.map(([, output]) => (Array.isArray(output) ? output[1] : null)),
    null
  );

  const allSkipSentence = allEqualOr(
    actions.map(([{ skipSentence }]) => skipSentence),
    null
  );

  const [normal, shifted] = actions.map(
    ([{ exact, sentenceShift, skipSentence }, output]) => {
      const lines = [];

      if (allSkipSentence === null && skipSentence) {
        lines.push("prev_chord_skipsentence = true;");
      }

      if (sentenceShift !== undefined) {
        lines.push("if (prev_chord_length && !prev_chord_skipsentence) {");
        lines.push("  if (prev_chord_space) {");
        lines.push("    tap_code16(KC_BSPC);");
        lines.push("  }");
        lines.push("  space = prev_chord_space;");
        if (sentenceShift) {
          lines.push("  oneshot_mods = MOD_MASK_SHIFT;");
        }
        lines.push("} else {");
        lines.push(`  space = ${exact ? "false" : "true"};`);
        lines.push("}");
      } else if (allExact === null && exact) {
        lines.push("space = false;");
      }

      if (Array.isArray(output) || sentenceShift !== undefined) {
        const [calls, length] = output;
        if (allLength === null) {
          lines.push(`last_chord_length = ${length};`);
        }
        lines.push(...calls);
      } else {
        lines.push(`append = "${output}";`);
      }
      return lines;
    }
  );

  const lines = [];

  if (allExact) {
    lines.push("space = false;");
  }
  if (allLength !== null) {
    lines.push(`last_chord_length = ${allLength};`);
  }
  if (allSkipSentence) {
    lines.push("prev_chord_skipsentence = true;");
  }

  if (shifted && normal.join("\n") !== shifted.join("\n")) {
    lines.push(`if (${conditional}) {`);
    lines.push(...shifted.map((line) => `  ${line}`));
    lines.push("} else {");
    lines.push(...normal.map((line) => `  ${line}`));
    lines.push("}");
  } else {
    lines.push(...normal);
  }

  return lines;
};

const qmkPreamble = (chords, personalFile) => {
  if (personalFile) {
    return [];
  }

  return [
    macro(
      "COMBO_FOR_CHORD",
      ["name", "..."],
      "const uint16_t PROGMEM chord_##name[] = {__VA_ARGS__, COMBO_END};"
    ),
    "",
    macro(
      "CHORD_COMBO",
      ["name"],
      "[CHORD_##name] = COMBO_ACTION(chord_##name)"
    ),
    "",
    '#include "personal.c"',
  ];
};

const qmkEnum = (chords, personalFile) => {
  const normalLines = [];
  const shiftedLines = [];
  const personalEnum = "PERSONAL_CHORD_ENUM";
  const personalShiftedEnum = "PERSONAL_SHIFTED_ENUM";

  chords.forEach(({ identifier, tap, hold }) => {
    normalLines.push(`CHORD_${identifier},`);
    if ("shift" in tap || (hold && "shift" in hold)) {
      shiftedLines.push(`CHORD_S_${identifier},`);
    }
  });

  if (personalFile) {
    return [
      macro(personalEnum, null, normalLines),
      macro(personalShiftedEnum, null, shiftedLines),
    ];
  } else {
    return [
      macro("CHORD_ENUM", null, [
        ...normalLines,
        personalEnum,
        ...shiftedLines,
        personalShiftedEnum,
      ]),
    ];
  }
};

const qmkCombos = (chords) => {
  const lines = [];

  chords.forEach((chord) => {
    lines.push(`COMBO_FOR_CHORD(${chord.identifier}, ${qmkCombo(chord)});`);
    if ("shift" in chord.tap || (chord.hold && "shift" in chord.hold)) {
      lines.push(
        `COMBO_FOR_CHORD(S_${chord.identifier}, ${qmkCombo(chord, true)});`
      );
    }
  });

  return lines;
};

const qmkActions = (chords, personalFile) => {
  const lines = [];
  const personalCombos = "PERSONAL_CHORD_COMBOS";

  chords.forEach(({ identifier, tap, hold }) => {
    lines.push(`CHORD_COMBO(${identifier}),`);
    if ("shift" in tap || (hold && "shift" in hold)) {
      lines.push(`CHORD_COMBO(S_${identifier}),`);
    }
  });

  if (!personalFile) {
    lines.push(personalCombos);
  }

  return [macro(personalFile ? personalCombos : "CHORD_COMBOS", null, lines)];
};

const qmkGlobals = [
  "bool releasedWithinTapThreshold = true;",
  "deferred_token chord_token = INVALID_DEFERRED_TOKEN;",
  "uint16_t prev_chord_length;",
  "bool prev_chord_space = false;",
  "bool prev_chord_skipsentence = false;",
  "bool chord_shifted;",
];

const qmkReleaseFunction = (chords, personalFile) => {
  const personalCases = "PERSONAL_RELEASE_CASES";
  const intro = `void process_chord_release(uint16_t combo_index) {
  cancel_deferred_exec(chord_token);

  bool space = true;
  char *append = NULL;
  prev_chord_length = last_chord_length;
  last_chord_length = 0;

  uint8_t mods = get_mods();
  uint8_t oneshot_mods = get_oneshot_mods();

  del_mods(MOD_MASK_SHIFT);
  del_weak_mods(MOD_MASK_SHIFT);
  del_oneshot_mods(MOD_MASK_SHIFT);

  switch(combo_index) {`;

  const outro = `    ${personalCases}
    default:
      set_mods(mods);
      set_oneshot_mods(oneshot_mods);
      last_chord_length = prev_chord_length;
      return;
  }

  if (append != NULL) {
    if (chord_shifted && append[0] >= 'a' && append[0] <= 'z') {
      add_oneshot_mods(MOD_MASK_SHIFT);
    }
    SEND_STRING(append);
    last_chord_length += strlen(append);
  }

  prev_chord_space = space;
  if (space) {
    tap_code(KC_SPC);
    last_chord_length++;
  }

  if (releasedWithinTapThreshold) {
    emit_virt_combo(last_chord, chord_shifted, VIRT_CHORD_ENDED_TAP);
  }

  set_mods(mods);
  set_oneshot_mods(oneshot_mods);
}`;

  const cases = [];
  chords.forEach((chord) => {
    const branch = [];
    const hasShift =
      "shift" in chord.tap || (chord.hold && "shift" in chord.hold);

    branch.push(`    case CHORD_${chord.identifier}:`);
    if (hasShift) {
      branch.push(`    case CHORD_S_${chord.identifier}:`);
    }

    if (chord.tap.behavior) {
      branch.push("      last_chord_length = prev_chord_length;");
      branch.push("      space = false;");
      if (chord.hold) {
        const down = qmkBehaviorAction(chord.tap, true);
        const up = qmkBehaviorAction(chord.tap, false);
        if (down || up) {
          branch.push(`      if (releasedWithinTapThreshold) {`);
          if (down) {
            branch.push(...down.map((line) => `        ${line}`));
          }
          if (up) {
            branch.push(...up.map((line) => `        ${line}`));
          }
        }
        const holdUp = qmkBehaviorAction(chord.hold, false);
        if (holdUp) {
          if (down || up) {
            branch.push(`      } else {`);
          } else {
            branch.push(`      if (!releasedWithinTapThreshold) {`);
          }
          branch.push(...holdUp.map((line) => `        ${line}`));
        }
        branch.push(`      }`);
      } else {
        const up = qmkBehaviorAction(chord.tap, false);
        if (!up) {
          return;
        }
        branch.push(...up.map((line) => `      ${line}`));
      }
    } else {
      if (!chord.hold) {
        return;
      }

      branch.push("      if (!releasedWithinTapThreshold) {");
      branch.push("        last_chord_length = prev_chord_length;");
      branch.push("        return;");
      branch.push("      }");
      branch.push(
        ...qmkOutputActionCase(
          chord.tap,
          `chord_shifted || combo_index == CHORD_S_${chord.identifier}`
        ).map((line) => `      ${line}`)
      );
    }

    branch.push("      break;");

    cases.push(...branch);
  });

  if (personalFile) {
    return [macro(personalCases, null, cases)];
  } else {
    return [...intro.split("\n"), ...cases, ...outro.split("\n")];
  }
};

const qmkPressFunction = (chords, personalFile, holdFunc) => {
  const firstShiftedChord = chords.find(
    (chord) => "shift" in chord.tap || (chord.hold && "shift" in chord.hold)
  );

  const personalCases = holdFunc ? "PERSONAL_HOLD_CASES" : "PERSONAL_TAP_CASES";

  const returnStatement = holdFunc ? "return 0" : "return";

  const tapIntro = `void process_chord_event(uint16_t combo_index, bool pressed) {
  if (!pressed) {
    process_chord_release(combo_index);
    ${returnStatement};
  }

  releasedWithinTapThreshold = true;
  prev_chord_length = last_chord_length;
  prev_chord_skipsentence = false;

  last_chord_length = 0;
  last_chord = combo_index;
  last_chord_cycle = 0;

  char *append = NULL;
  bool space = true;
  bool scheduleTimer = false;

  uint8_t mods = get_mods();
  uint8_t oneshot_mods = 0;
  bool mod_shifted = (mods | get_weak_mods() | get_oneshot_mods()) & MOD_MASK_SHIFT;
  del_mods(MOD_MASK_SHIFT);
  del_weak_mods(MOD_MASK_SHIFT);
  del_oneshot_mods(MOD_MASK_SHIFT);

  bool combo_shifted = combo_index >= CHORD_S_${firstShiftedChord.identifier};
  chord_shifted = mod_shifted || combo_shifted;

  switch(combo_index) {`;

  const holdIntro = `uint32_t process_chord_hold(uint32_t trigger_time, void* cb_arg) {
  uint16_t combo_index = last_chord;

  releasedWithinTapThreshold = false;

  char *append = NULL;
  bool space = true;
  last_chord_length = 0;

  uint8_t mods = get_mods();
  uint8_t oneshot_mods = 0;
  del_mods(MOD_MASK_SHIFT);
  del_weak_mods(MOD_MASK_SHIFT);
  del_oneshot_mods(MOD_MASK_SHIFT);

  switch(combo_index) {`;

  const tapOutro = `    ${personalCases}
    default:
      space = false;
      last_chord_length = prev_chord_length;
      break;
  }

  if (append != NULL) {
    if (chord_shifted && append[0] >= 'a' && append[0] <= 'z') {
      add_oneshot_mods(MOD_MASK_SHIFT);
    }
    SEND_STRING(append);
    last_chord_length += strlen(append);
  }

  prev_chord_space = space;
  if (space) {
    tap_code(KC_SPC);
    last_chord_length++;
  }

  if (scheduleTimer) {
    chord_token = defer_exec(TAPPING_TERM, process_chord_hold, NULL);
  }

  emit_virt_combo(last_chord, chord_shifted, scheduleTimer ? VIRT_CHORD_ENDED_INDETERMINATE : VIRT_CHORD_ENDED_TAP);

  set_mods(mods);
  set_oneshot_mods(oneshot_mods);

  ${returnStatement};
}`;

  const holdOutro = `    ${personalCases}
    default:
      set_mods(mods);
      set_oneshot_mods(oneshot_mods);
      last_chord_length = prev_chord_length;
      ${returnStatement};
  }

  if (append != NULL) {
    if (chord_shifted && append[0] >= 'a' && append[0] <= 'z') {
      add_oneshot_mods(MOD_MASK_SHIFT);
    }
    SEND_STRING(append);
    last_chord_length += strlen(append);
  }

  prev_chord_space = space;
  if (space) {
    tap_code(KC_SPC);
    last_chord_length++;
  }

  emit_virt_combo(last_chord, chord_shifted, VIRT_CHORD_ENDED_HOLD);
  set_mods(mods);
  set_oneshot_mods(oneshot_mods);
  ${returnStatement};
}`;

  const cases = [];
  const timerChords = [];
  chords.forEach((chord) => {
    if (holdFunc && !chord.hold) {
      return;
    }
    if (!holdFunc && chord.hold) {
      timerChords.push(chord);
      return;
    }

    const action = holdFunc ? chord.hold : chord.tap;
    let hasShift =
      "shift" in chord.tap || (chord.hold && "shift" in chord.hold);

    const branch = [];
    branch.push(`    case CHORD_${chord.identifier}:`);
    if (hasShift) {
      branch.push(`    case CHORD_S_${chord.identifier}:`);
    }

    if (action.behavior) {
      branch.push("      space = false;");
      branch.push("      last_chord_length = prev_chord_length;");
      const down = qmkBehaviorAction(action, true);
      if (!down) {
        return;
      }
      branch.push(...down.map((line) => `      ${line}`));
    } else {
      branch.push(
        ...qmkOutputActionCase(
          action,
          `chord_shifted || combo_index == CHORD_S_${chord.identifier}`
        ).map((line) => `      ${line}`)
      );
    }
    branch.push("      break;");
    cases.push(...branch);
  });

  if (timerChords.length) {
    timerChords.forEach(({ identifier, tap, hold }) => {
      cases.push(`    case CHORD_${identifier}:`);
      if ("shift" in tap || (hold && "shift" in hold)) {
        cases.push(`    case CHORD_S_${identifier}:`);
      }
    });
    cases.push("      space = false;");
    cases.push("      last_chord_length = prev_chord_length;");
    cases.push("      scheduleTimer = true;");
    cases.push("      break;");
  }

  const intro = holdFunc ? holdIntro : tapIntro;
  const outro = holdFunc ? holdOutro : tapOutro;

  if (personalFile) {
    return [macro(personalCases, null, cases)];
  } else {
    return [...intro.split("\n"), ...cases, ...outro.split("\n")];
  }
};

const qmkDupActionCase = (action, conditional) => {
  const actions = [action];
  if ("shift" in action && conditional) {
    actions.push(action.shift);
  }

  const [normal, shifted] = actions.map(({ alternates }) => {
    const lines = [];
    if (alternates?.length) {
      const allBackspaces = allEqualOr(
        alternates.map(({ backspaces }) => backspaces),
        null
      );
      if (allBackspaces) {
        lines.push(`backspaces = ${allBackspaces};`);
      }

      const allExact = allEqualOr(
        alternates.map(({ exact }) => exact),
        null
      );
      if (allExact) {
        lines.push("space = false;");
      }

      lines.push("switch(last_chord_cycle) {");
      alternates.forEach(({ fromIdx, toIdx, backspaces, append, exact }) => {
        lines.push(`  case ${fromIdx}:`);
        if (allBackspaces === null && backspaces) {
          lines.push(`    backspaces = ${backspaces};`);
        }
        if (allExact === null && exact) {
          lines.push("    space = false;");
        }
        if (toIdx !== fromIdx + 1) {
          lines.push(`    next_chord_cycle = ${toIdx};`);
        }
        if (append.length) {
          lines.push(`    append = "${append}";`);
        }
        lines.push("  break;");
      });
      lines.push("}");
    } else {
      lines.push("space = false;");
    }
    return lines;
  });

  const lines = [];

  if (shifted && normal.join("\n") !== shifted.join("\n")) {
    lines.push(`if (${conditional}) {`);
    lines.push(...shifted.map((line) => `  ${line}`));
    lines.push("} else {");
    lines.push(...normal.map((line) => `  ${line}`));
    lines.push("}");
  } else {
    lines.push(...normal);
  }

  return lines;
};

const qmkDupFunction = (chords, personalFile) => {
  const personalCases = "PERSONAL_DUP_CASES";
  const intro = `uint8_t process_chord_dup(uint16_t last_chord, uint8_t last_chord_cycle) {
  uint8_t next_chord_cycle = last_chord_cycle + 1;
  uint8_t backspaces = 0;
  char *append = NULL;
  bool space = true;

  uint8_t mods = get_mods();
  uint8_t oneshot_mods = 0;
  del_mods(MOD_MASK_SHIFT);
  del_weak_mods(MOD_MASK_SHIFT);
  del_oneshot_mods(MOD_MASK_SHIFT);

  switch(last_chord) {`;

  const cases = [];
  chords
    .filter((chord) => chord.tap?.alternates || chord.hold?.alternates)
    .forEach(({ tap, hold, identifier }) => {
      const hasShift = "shift" in tap || (hold && "shift" in hold);

      cases.push(`    case CHORD_${identifier}:`);
      if (hasShift) {
        cases.push(`    case CHORD_S_${identifier}:`);
      }

      const actions = [tap];
      if (hold) {
        actions.push(hold);
      }

      const [tapBranch, holdBranch] = actions.map((action) =>
        qmkDupActionCase(
          action,
          `chord_shifted || last_chord == CHORD_S_${identifier}`
        ).map((line) => `      ${line}`)
      );

      if (!hold || tapBranch.join("\n") === holdBranch.join("\n")) {
        cases.push(...tapBranch);
      } else {
        cases.push("      if (releasedWithinTapThreshold) {");
        cases.push(...tapBranch.map((line) => `  ${line}`));
        cases.push("      } else {");
        cases.push(...holdBranch.map((line) => `  ${line}`));
        cases.push("      }");
      }

      cases.push("      break;");
    });

  const outro = `    ${personalCases}
    default:
      space = false;
      break;
  }

  for (uint8_t i = 0; i < backspaces; i++) {
    tap_code(KC_BSPC);
  }
  last_chord_length -= backspaces;

  if (append != NULL) {
    SEND_STRING(append);
    last_chord_length += strlen(append);
  }

  prev_chord_space = space;
  if (space) {
    tap_code(KC_SPC);
    last_chord_length++;
  }

  set_mods(mods);
  set_oneshot_mods(oneshot_mods);

  return next_chord_cycle;
}`;

  if (personalFile) {
    return [macro(personalCases, null, cases)];
  } else {
    return [...intro.split("\n"), ...cases, ...outro.split("\n")];
  }
};

const qmkFunctions = (chords, personalFile) => {
  if (personalFile) {
    return [
      ...qmkReleaseFunction(chords, personalFile),
      "",
      ...qmkPressFunction(chords, personalFile, true),
      "",
      ...qmkPressFunction(chords, personalFile, false),
      "",
      ...qmkDupFunction(chords, personalFile),
    ];
  } else {
    return [
      macro(
        "CHORD_FUNC_RELEASE",
        null,
        qmkReleaseFunction(chords, personalFile)
      ),
      "",
      macro(
        "CHORD_FUNC_HOLD",
        null,
        qmkPressFunction(chords, personalFile, true)
      ),
      "",
      macro(
        "CHORD_FUNC_TAP",
        null,
        qmkPressFunction(chords, personalFile, false)
      ),
      "",
      macro("CHORD_FUNC_DUP", null, qmkDupFunction(chords, personalFile)),
      "",
      macro("CHORD_FUNCS", null, [
        "CHORD_FUNC_RELEASE",
        "CHORD_FUNC_HOLD",
        "CHORD_FUNC_TAP",
        "CHORD_FUNC_DUP",
      ]),
    ];
  }
};

const qmkConfig = (chordsAndCategories, personalFile) => {
  const lines = [];
  const chords = chordsAndCategories.filter(
    (chord) =>
      typeof chord === "object" &&
      !!chord.personal === personalFile &&
      !(chord.builtin === true || chord.builtin === "qmk")
  );

  lines.push(...qmkPreamble(chords, personalFile), "");
  lines.push(...qmkEnum(chords, personalFile), "");
  lines.push(...qmkCombos(chords), "");
  lines.push(...qmkActions(chords, personalFile), "");
  if (!personalFile) {
    lines.push(...qmkGlobals, "");
  }
  lines.push(...qmkFunctions(chords, personalFile), "");

  return lines;
};

const zmkPress = {
  " ": "&kp SPC",
  "!": "&kp EXCL",
  "'": "&kp APOS",
  ",": "&kp COMMA",
  ".": "&kp DOT",
  "/": "&kp SLASH",
  ":": "&kp COLON",
  ";": "&kp SEMI",
  "@": "&kp AT",
  "*": "&kp ASTERISK",
  "\b": "&kp BSPC",
  "<SKLS>": "&sk LSHFT",
  "?": "&kp QMARK",
  "¢": "&kp LA(N4)",
  "£": "&kp LA(N3)",
  "¥": "&kp INT_YEN",
  "°": "&kp LA(LS(N8))",
  "•": "&kp LA(N8)",
  "‽": "&kp QMARK",
  "€": "&kp LA(LS(N2))",
  "←": "&kp QMARK",
  "↑": "&kp QMARK",
  "→": "&kp QMARK",
  "↓": "&kp QMARK",
  "∞": "&kp LA(N5)",
  "⋯": "&kp QMARK",
  "✔": "&kp QMARK",
  "✗": "&kp QMARK",
  "⌘": "&kp QMARK",
  λ: "&kp QMARK",
};

"abcdefghijklmnopqrstuvwxyz".split("").forEach((alpha) => {
  const upper = alpha.toUpperCase();
  zmkPress[upper] = `&kp LS(${upper})`;
  zmkPress[alpha] = `&kp ${upper}`;
});
"0123456789".split("").forEach((digit) => {
  zmkPress[digit] = `&kp NUM_${digit}`;
});

const zmkPresses = (output) => {
  const presses = [];
  let o = output;
  while (o.length) {
    let key;
    const special = o.match(/^<\w+>/);
    if (special) {
      key = special[0];
    } else {
      key = o.substring(0, 1);
    }

    if (!(key in zmkPress)) {
      throw new Error(`Unable to handle zmkPress for '${key}'`);
    }

    o = o.substring(key.length);
    presses.push(zmkPress[key]);
  }

  return presses;
};

const zmkOutputAction = ({ behavior, output, exact }) => {
  if (behavior) {
    return zmkBehavior(behavior);
  }

  let o = output;
  if (!exact) {
    o += " ";
  }
  return zmkPresses(o);
};

const zmkOutput = ({ identifier, tap, hold }) => {
  const macro = `ch_${identifier}`;

  if (hold) {
    const macros = [`${macro}_t`, `${macro}_h`];
    return [macros, zmkOutputAction(tap), zmkOutputAction(hold)];
  }

  const presses = zmkOutputAction(tap);
  return presses.length === 1
    ? [null, presses[0], null]
    : [macro, presses.join(" "), null];
};

const zmkModifier = {
  Shift: "LSHIFT",
  Ctrl: "LCTRL",
  Alt: "LALT",
  Gui: "LGUI",
  Hyper: "LG(LA(LCTRL))",
};

const zmkBehavior = (behavior) => {
  if (behavior.startsWith("oneshot-")) {
    const rest = behavior.replace("oneshot-", "");
    if (rest in layerIndex) {
      return [`&sl ${rest.toUpperCase()}`];
    } else if (rest in zmkModifier) {
      return [`&sk ${zmkModifier[rest]}`];
    }
  }

  switch (behavior) {
    case "delete-word":
      return [`&kp LA(BSPC)`];

    default:
      throw new Error(`Unimplemented zmkBehavior '${behavior}'`);
  }
};

const zmkCombo = (chord) => chord.combo.map((key) => zmkKey[key]).join(" ");

const zmkPreamble = (chords, personalFile) => {
  if (personalFile) {
    return [];
  }

  return [
    macro("str", ["s"], "#s"),
    "",
    macro(
      "THCHORD",
      ["name", "tapMacro", "holdMacro"],
      [
        "name: name {",
        '  compatible = "zmk,behavior-hold-tap";',
        "  label = str(name);",
        "  #binding-cells = <2>;",
        "  tapping_term_ms = <200>;",
        "  quick_tap_ms = <0>;",
        '  flavor = "tap-preferred";',
        "  bindings = <&holdMacro>, <&tapMacro>;",
        "};",
      ]
    ),
    "",
    macro(
      "COMBO",
      ["name", "keypress", "keypos"],
      [
        "combo_##name {",
        "  timeout-ms = <60>;",
        "  bindings = <keypress>;",
        "  key-positions = <keypos>;",
        "};",
      ]
    ),
    "",
    macro(
      "LAYER_CHORD",
      ["name", "keypress", "keypos", "lays"],
      [
        "chord_##name {",
        "  timeout-ms = <60>;",
        "  bindings = <keypress>;",
        "  key-positions = <keypos>;",
        "  layers = <lays>;",
        "};",
      ]
    ),
    "",
    macro(
      "CHORD",
      ["name", "keypress", "keypos"],
      ["LAYER_CHORD(name, keypress, keypos, ALPHA SENTENCE)"]
    ),
    "",
    macro(
      "MACRO",
      ["name", "keys"],
      [
        "name: name##_macro {",
        "label = #name;",
        'compatible = "zmk,behavior-macro";',
        "#binding-cells = <0>;",
        "tap-ms = <1>;",
        "wait-ms = <1>;",
        "bindings = <keys>;",
        "};",
      ]
    ),
    "",
    macro(
      "CHMAC",
      ["name", "keys"],
      [
        "name: name##_macro {",
        "  label = #name;",
        '  compatible = "zmk,behavior-macro";',
        "  #binding-cells = <0>;",
        "  tap-ms = <1>;",
        "  wait-ms = <1>;",
        "  bindings = <keys>, <&to SENTENCE>;",
        "};",
      ]
    ),
    "",
    '#include "personal.keymap"',
  ];
};

const zmkBehaviors = (chords) => {
  const lines = ["/ {", "  behaviors {"];

  chords.forEach((chord) => {
    const [macroIdentifier] = zmkOutput(chord);

    if (!Array.isArray(macroIdentifier)) {
      return;
    }

    const macro = "THCHORD";
    const args = [`ht_${chord.identifier}`, ...macroIdentifier];

    lines.push(`    ${macro}(${args.join(", ")})`);
  });

  lines.push("  };", "};");

  return lines;
};

const zmkCombos = (chords) => {
  const lines = ["/ {", "  combos {", '    compatible = "zmk,combos";'];

  chords.forEach((chord) => {
    let macro = "CHORD";
    const [macroIdentifier, tapBehavior] = zmkOutput(chord);

    const args = [`ch_${chord.identifier}`];

    if (Array.isArray(macroIdentifier)) {
      args.push(`&ht_${chord.identifier} 0 0`);
    } else {
      args.push(macroIdentifier ? `&${macroIdentifier}` : tapBehavior);
    }

    args.push(zmkCombo(chord));

    if (chord.layers) {
      macro = "LAYER_CHORD";
      args.push(chord.layers.map((l) => l.toUpperCase()).join(" "));
    }

    lines.push(`    ${macro}(${args.join(", ")})`);
  });

  lines.push("  };", "};");

  return lines;
};

const zmkMacros = (chords) => {
  const lines = ["/ {", "  macros {"];

  chords.forEach((chord) => {
    const { tap, hold } = chord;
    const [identifier, tapBehavior, holdBehavior] = zmkOutput(chord);
    if (!identifier || tapBehavior === null) {
      return;
    }

    const macros = Array.isArray(identifier)
      ? [
          [identifier[0], tapBehavior, tap.skipSentence || tap.behavior],
          [identifier[1], holdBehavior, hold.skipSentence || hold.behavior],
        ]
      : [[identifier, tapBehavior, tap.skipSentence]];

    macros.forEach(([identifier, behavior, skipSentence]) => {
      const args = [identifier, behavior];

      let macro = "MACRO";
      if (!skipSentence) {
        macro = "CHMAC";
      }

      lines.push(`    ${macro}(${args.join(", ")})`);
    });
  });

  lines.push("  };", "};");

  return lines;
};

const zmkChords = (chordsAndCategories) => {
  const chords = [];
  chordsAndCategories
    .filter(
      (chord) =>
        typeof chord === "object" &&
        !(chord.builtin === true || chord.builtin === "zmk")
    )
    .forEach((chord) => {
      [false, true].forEach((shift) => {
        const combo = [...chord.combo];
        let identifier = chord.identifier;
        let tapAction = chord.tap;
        let holdAction = chord.hold;

        if (shift) {
          let skip = true;
          if (tapAction.shift) {
            tapAction = tapAction.shift;
            skip = false;
          }
          if (holdAction?.shift) {
            holdAction = holdAction.shift;
            skip = false;
          }
          if (skip) {
            return;
          }
          combo.push(shiftBase[0]);
          identifier = "S_" + identifier;
        }

        if (tapAction.sentenceShift !== undefined) {
          chords.push({
            ...chord,
            combo,
            identifier: `${identifier}_s`,
            tap: {
              ...tapAction,
              output: `\b${tapAction.output} ${
                tapAction.sentenceShift ? "<SKLS>" : ""
              }`,
            },
            layers: ["Sentence"],
          });
          chords.push({
            ...chord,
            combo,
            identifier,
            tap: tapAction,
            hold: holdAction,
            layers: zmkLayers,
          });
        } else {
          chords.push({
            ...chord,
            identifier,
            combo,
            tap: tapAction,
            hold: holdAction,
          });
        }
      });
    });

  return chords;
};

const zmkConfig = (chordsAndCategories, personalFile) => {
  const lines = [];
  const chords = zmkChords(chordsAndCategories).filter(
    ({ personal }) => !!personal === personalFile
  );

  lines.push(...zmkPreamble(chords, personalFile), "");
  lines.push(...zmkBehaviors(chords), "");
  lines.push(...zmkCombos(chords), "");
  lines.push(...zmkMacros(chords), "");

  return lines;
};

const zmkSettings = (chordsAndCategories, original) => {
  const lines = dropAfter(original, new RegExp(/^# Chording$/));

  let maxQueueSize = 0;
  let maxKeysPerCombo = 0;
  let maxPressedCombos = 8;
  const combosPerKey = {};

  zmkChords(chordsAndCategories).forEach((chord) => {
    const { combo, tap, hold } = chord;

    if (combo.length > maxKeysPerCombo) {
      maxKeysPerCombo = combo.length;
    }

    [tap, hold].filter(Boolean).forEach(({ behavior, output, exact }) => {
      if (behavior) {
      } else {
        let presses = zmkPresses(output).length;
        if (exact) {
          presses++;
        }
        presses = presses * 2 + 5;

        if (presses > maxQueueSize) {
          maxQueueSize = presses;
        }
      }
    });

    combo.forEach((key) => {
      combosPerKey[key] = (combosPerKey[key] || 0) + 1;
    });
  });

  let maxCombosPerKey = 0;
  Object.entries(combosPerKey).forEach(([, combos]) => {
    if (combos > maxCombosPerKey) {
      maxCombosPerKey = combos;
    }
  });

  lines.push("# Chording");
  lines.push("");
  lines.push(`CONFIG_ZMK_BEHAVIORS_QUEUE_SIZE=${maxQueueSize}`);
  lines.push(`CONFIG_ZMK_COMBO_MAX_COMBOS_PER_KEY=${maxCombosPerKey}`);
  lines.push(`CONFIG_ZMK_COMBO_MAX_KEYS_PER_COMBO=${maxKeysPerCombo}`);
  lines.push(`CONFIG_ZMK_COMBO_MAX_PRESSED_COMBOS=${maxPressedCombos}`);
  lines.push("");

  return lines;
};

const generateKeymap = ({ layout, chords }) => {
  const layers = {};

  layout.layers.forEach((layer) => {
    [
      [layer, layer, layer, false, ["Alpha"]],
      [`${layer}-Hold`, layer, `${layer} (hold)`, true, [layer, "Alpha"]],
    ].forEach(([layer, baseLayer, layerLabel, isHold, inheritLayers]) => {
      if (layer === "Function-Hold") {
        return;
      }

      const combos = [];
      const left = [];
      const right = [];
      const left_thumbs = [];
      const right_thumbs = [];
      const thumbrow = layout.keymap.length - 1;

      layout.keymap.forEach((row, r) => {
        if (r < thumbrow) {
          left.push([]);
          right.push([]);
        }

        row.forEach((key, c) => {
          let target;
          if (r === thumbrow) {
            target = c < 2 ? left_thumbs : right_thumbs;
          } else {
            target = c < 5 ? left[r] : right[r];
          }

          const k = [layer, ...inheritLayers]
            .map((l) => key[l])
            .find((k) => k !== null);
          const inherited = key[layer] === null;

          let label = k;
          if (label in tidyKeymap) {
            label = tidyKeymap[label];
          }
          if (label.match(/^[a-z]$/)) {
            label = label.toUpperCase();
          }
          if (isHold && inherited && label !== "") {
            label = `⌘${label}`;
          }
          if (label === "") {
            label = null;
          }
          target.push(label);
        });
      });

      chords.forEach((chord) => {
        if (isHold && !chord.hold) {
          return;
        }

        const action = isHold ? chord.hold : chord.tap;

        if (chord.combo.length > 2) {
          return;
        }

        if (chord.layers) {
          if (!chord.layers.includes(baseLayer)) {
            return;
          }
        }

        if ("output" in action && action.output.match(/^[a-z]+$/i)) {
          return;
        }

        const positions = chord.combo.map((key) => zmkKey[key]);
        if (positions.filter((p) => layout.keys[p][layer] === "").length) {
          return;
        }

        let label = action.output ?? action.behavior;
        if (label in tidyKeymap) {
          label = tidyKeymap[label];
        }
        if (label === null) {
          return;
        }

        combos.push({
          key: label,
          positions,
        });
      });

      layers[layerLabel] = {
        left,
        right,
        left_thumbs,
        right_thumbs,
        combos,
      };
    });
  });

  return {
    layout: {
      split: true,
      rows: layers.Alpha.left.length,
      columns: layers.Alpha.left[0].length,
      thumbs: layers.Alpha.left_thumbs.length,
    },
    layers,
  };
};

const chordsAndCategories = parseChords(
  chordFiles.map((file) => JSON.parse(fs.readFileSync(file)))
);

fs.writeFileSync(
  readmeFile,
  readmeContent(
    chordsAndCategories,
    fs.readFileSync(readmeFile, "utf-8").split("\n")
  ).join("\n")
);
fs.writeFileSync(
  qmkChordFile,
  qmkConfig(chordsAndCategories, false).join("\n")
);
fs.writeFileSync(
  qmkPersonalFile,
  qmkConfig(chordsAndCategories, true).join("\n")
);
fs.writeFileSync(
  zmkChordFile,
  zmkConfig(chordsAndCategories, false).join("\n")
);
fs.writeFileSync(
  zmkPersonalFile,
  zmkConfig(chordsAndCategories, true).join("\n")
);
fs.writeFileSync(
  zmkConfigFile,
  zmkSettings(
    chordsAndCategories,
    fs.readFileSync(zmkConfigFile, "utf-8").split("\n")
  ).join("\n")
);
fs.writeFileSync(
  processedChords,
  JSON.stringify({
    layout,
    chords: chordsAndCategories.filter((chord) => typeof chord === "object"),
  })
);
fs.writeFileSync(
  keymapFile,
  JSON.stringify(
    generateKeymap({
      layout,
      chords: chordsAndCategories.filter((chord) => typeof chord === "object"),
    })
  )
);
