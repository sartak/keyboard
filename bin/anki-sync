#!/usr/bin/env node
const fs = require("fs");
const sqlite3 = require("better-sqlite3");
const inputFile = "processed.json";
const outputFile = "processed-anki.json";
const templateDirectory = "web";
const ankiFrontFile = `${templateDirectory}/anki-front.html`;
const ankiBackFile = `${templateDirectory}/anki-back.html`;
const ankiStyleFile = `${templateDirectory}/anki-style.css`;
const ankiShellFile = `${templateDirectory}/anki-shell.html`;
const shellOutput = "anki-test.html";

const [nodeArg, scriptArg] = process.argv;
if (process.argv.length !== 3 && process.argv.length !== 4) {
  console.error(
    `usage: ${nodeArg} ${scriptArg} collection.anki2 note-type\n` +
      `   or: ${nodeArg} ${scriptArg} shell-combo`
  );
  process.exit(1);
}

const shellCombo = process.argv.length === 3 ? process.argv[2] : null;
const ankiDatabase = process.argv.length === 4 ? process.argv[2] : null;
const noteType = process.argv.length === 4 ? process.argv[3] : null;

if (ankiDatabase !== null && !fs.existsSync(ankiDatabase)) {
  throw new Error(`anki sqlite database '${ankiDatabase}' does not exist`);
}

const config = JSON.parse(fs.readFileSync(inputFile));
const { layout } = config;

const tidyChar = {
  "\b": "⌫",
  "\n": "↵",
};

const tidy = (s) =>
  s
    .split("")
    .map((c) => (c in tidyChar ? tidyChar[c] : c))
    .join("");

const unescape = (html) =>
  html
    .replaceAll(/&lt;/g, "<")
    .replaceAll(/&gt;/g, ">")
    .replaceAll(/&amp;/g, "&");

const fillTemplate = (template, partials = {}) => {
  return template.replaceAll(/{{\s*(.*?)\s*}}/g, (_, name) => {
    if (name in partials) {
      return partials[name];
    }

    const file = `${templateDirectory}/${name}`;
    if (fs.existsSync(file)) {
      const content = fillTemplate(String(fs.readFileSync(file)), partials);
      partials[name] = content;
      return content;
    }

    throw new Error(`Partial ${name} cannot be found`);
  });
};

const defaultPartials = {
  layout: JSON.stringify(layout),
};

const generateTemplates = () => {
  const partials = {
    ...defaultPartials,
    FrontSide: "{{FrontSide}}",
    Output: "{{Output}}",
    Input: "{{Input}}",
  };

  const front = fillTemplate(String(fs.readFileSync(ankiFrontFile)), partials);
  const back = fillTemplate(String(fs.readFileSync(ankiBackFile)), partials);
  const style = fillTemplate(String(fs.readFileSync(ankiStyleFile)), partials);

  return [front, back, style];
};

const generateShell = (input, output) => {
  const partials = {
    ...defaultPartials,
    Output: output,
    Input: input,
  };

  partials.FrontSide = fillTemplate(
    String(fs.readFileSync(ankiFrontFile)),
    partials
  );

  partials.style = fillTemplate(
    String(fs.readFileSync(ankiStyleFile)),
    partials
  );

  partials.content = fillTemplate(
    String(fs.readFileSync(ankiBackFile)),
    partials
  );

  return fillTemplate(String(fs.readFileSync(ankiShellFile)), partials);
};

const checkTemplates = (anki, mid, noteConfig) => {
  let [ankiStyle] = String(noteConfig).split("*" + String.fromCharCode(0xfffd));
  ankiStyle = ankiStyle.substring(3);

  const templateStmt = anki.prepare(`
  SELECT config
  FROM templates
  WHERE ntid = ?
`);
  let i = 0;
  let ankiFront, ankiBack;
  for (const { config: templateConfig } of templateStmt.iterate(mid)) {
    [, ankiFront, , ankiBack] = String(templateConfig)
      .split(String.fromCharCode(0xfffd))
      .map((s) => s.substring(1));

    ankiFront = ankiFront.substring(0, ankiFront.length - 1);

    if (i++) {
      throw new Error("Multiple templates detected");
    }
  }

  const [expectedFront, expectedBack, expectedStyle] = generateTemplates();

  [
    ["front", expectedFront, ankiFront],
    ["back", expectedBack, ankiBack],
    ["style", expectedStyle, ankiStyle],
  ].forEach(([label, expected, got]) => {
    if (expected.trimEnd() !== got.trimEnd()) {
      console.warn(`Card template ${label} is stale, replace with`);
      console.warn("-".repeat(40));
      console.warn(expected);
      console.warn("-".repeat(40));
      console.warn("");
    }
  });
};

const getCards = () => {
  const cards = [];

  const anki = sqlite3(ankiDatabase);
  anki.pragma("journal_mode = WAL");

  const res = anki
    .prepare("SELECT id, config FROM notetypes WHERE name = ? COLLATE nocase")
    .get(noteType);

  if (!res) {
    throw new Error(`Note type '${noteType}' does not exist in Anki database`);
  }

  const { id: mid, config } = res;
  checkTemplates(anki, mid, config);

  const stmt = anki.prepare(`
  SELECT notes.id, notes.flds, notes.tags, cards.queue
  FROM notes
  LEFT JOIN cards ON cards.nid = notes.id
  WHERE notes.mid = ?
`);
  for (const { id, flds, tags: tagString, queue } of stmt.iterate(mid)) {
    const tags = tagString.split(" ").filter((t) => t.length);
    const [outputHtml, inputString] = flds.split("\x1F");
    const output = unescape(outputHtml);
    const inputs = unescape(inputString).split(" - ");
    let input = inputs.map((i) => i.split(" "));
    if (input.length === 1) {
      input = input[0];
    }

    if (inputString.match(/\n/)) {
      console.warn(`Found newline in input of nid:${id}`);
    }
    if (inputString.match(/<\s*\/?\s*\w+/)) {
      console.warn(`Found HTML tag in input of nid:${id}`);
    }

    let suspended;
    switch (queue) {
      case -1: // suspended
        suspended = true;
        break;

      case -3: // user buried (in scheduler 2)
      case -2: // sched buried (in scheduler 2), buried (in scheduler 1)
      case 0: // new
      case 1: // learning
      case 2: // review
      case 3: // in learning, next rev in at least a day after the previous review
      case 4: // preview
        suspended = false;
        break;

      default:
        suspended = undefined;
        console.warn(
          `Unable to determine suspended state for card nid:${id} for ${inputString} => ${output}`
        );
        break;
    }

    cards.push({ id, output, input, tags, suspended });
  }

  return cards;
};

if (shellCombo) {
  fs.writeFileSync(shellOutput, generateShell(shellCombo, ""));
  process.exit(0);
}

const cards = getCards();
const cardForInput = {};
const chordForCombo = {};
let studyingChords = 0;
let studyingOther = 0;

cards.forEach((card) => {
  let key;
  if (Array.isArray(card.input[0])) {
    key = card.input
      .map((i) =>
        i
          .map((c) => c.toUpperCase())
          .sort()
          .join("+")
      )
      .join(", ");
  } else {
    key = card.input
      .map((c) => c.toUpperCase())
      .sort()
      .join("+");
  }
  cardForInput[key] = card;
});

config.chords.forEach((chord) => {
  const key = chord.combo
    .map((c) => c.toUpperCase())
    .sort()
    .join("+");
  chordForCombo[key] = chord;
});

Object.values(chordForCombo).forEach((chord) => {
  const actions = [
    [false, false, chord.tap],
    [false, true, chord.tap?.shift],
    [true, false, chord.hold],
    [true, true, chord.hold?.shift],
  ];

  actions.forEach(([forHold, forShift, action]) => {
    if (!action) {
      return;
    }

    const alternates = [];
    if ("output" in action) {
      alternates.push([action.output, 0, false]);
    } else {
      alternates.push([action.behavior, 0, true]);
    }

    action.alternates?.forEach((alternate, i) => {
      if (alternate.toIdx === 0) {
        return;
      }
      alternates.push([alternate.to, i + 1, false]);
    });

    alternates.forEach(([result, dupCount, isBehavior]) => {
      let ok = true;
      const dups = dupCount ? ", Dup".repeat(dupCount) : "";

      const keyParts = [[...chord.combo]];
      if (chord.layers?.length) {
        keyParts.push([
          ...chord.layers.map((layer) => layout.keyForLayer[layer]),
          ...chord.combo,
        ]);
      }

      if (forHold) {
        keyParts.forEach((keyPart) => {
          keyPart.push("Hold");
        });
      }

      if (forShift) {
        keyParts.forEach((keyPart) => {
          keyPart.push("Shift");
        });
      }

      const keys = keyParts.map(
        (keyPart) =>
          keyPart
            .map((c) => c.toUpperCase())
            .sort()
            .join("+") + dups.toUpperCase()
      );

      const key = keys.find((key) => cardForInput[key]);
      const card = cardForInput[key];

      const combo = chord.combo.join("+") + dups;
      let context = `${forHold ? "hold" : "tap"}${
        forShift ? " shift" : ""
      } ${combo} => ${isBehavior ? result : tidy(result)}`;

      if (!card) {
        if (!action.intuited) {
          ok = false;
          console.warn(`No Anki card for chord: ${context}`);
        }
        return;
      }

      context = `card nid:${card.id} for ${context}`;
      if (!card.tags.includes("chord")) {
        ok = false;
        console.warn(`Missing tag 'chord' for ${context}`);
      }

      if (isBehavior) {
        if (card.output !== result) {
          ok = false;
          console.warn(
            `Card nid:${card.id} for combo ${combo} does not match expected behavior`
          );
          console.warn(` Card: ${card.output}`);
          console.warn(`Chord: ${result}`);
        }
      } else {
        let expected = tidy(result);
        if (expected.length === 1 && expected.match(/[a-zA-Z]/)) {
          expected += " (word)";
        }

        if (card.output !== expected) {
          ok = false;
          console.warn(
            `Card nid:${card.id} for combo ${combo} does not match expected output`
          );
          console.warn(` Card: ${card.output}`);
          console.warn(`Chord: ${expected}`);
        }
      }

      delete cardForInput[key];

      if (ok) {
        if (card.suspended === false) {
          studyingChords++;
        }
      }
    });
  });
});

Object.values(cardForInput).forEach((card) => {
  if (!card.tags.includes("chord")) {
    if (card.suspended === false) {
      studyingOther++;
    }
    return;
  }
  console.warn(
    `No chord found for Anki card nid:${card.id} ${card.input.join(" ")} => ${
      card.output
    }`
  );
});

fs.writeFileSync(outputFile, JSON.stringify(config));

console.log(
  `Studying ${studyingChords} of ${config.chords.length} chords, plus ${studyingOther} others`
);
